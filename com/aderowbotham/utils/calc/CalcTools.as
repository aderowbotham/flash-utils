package com.aderowbotham.utils.calc {			/**	 * @project com.aderowbotham.utils	 * @author Ade Rowbotham | www.aderowbotham.com	 * @copyright 2005 - 2008	 **/	 				public class CalcTools {						public function CalcTools(){						throw new Error("CalcTools should not be instantiated. All its methods are static.");					}																							public static function getRadians(d:Number):Number{			return (d/180)*Math.PI;		}						//shortcut - get the square		public static function square(num:Number):Number{			return num*num;		}														public static function getHypotenuse(xDistance:Number,yDistance:Number = NaN):Number{						//if yDistance is undefined make it the same as xDistance, 			if(isNaN(yDistance)){				yDistance = xDistance;			}						return Math.sqrt(square(xDistance)+square(yDistance));		}																				//returns the hypotenuse and polarity in the		public static function getHypotenuseWithPolarity(xDistance:Number, yDistance:Number):CalcReturnObject{									//var polarityAxis:String = pA;			var returnObject : CalcReturnObject = new CalcReturnObject();									//work out axis is greater			if(Math.abs(xDistance) > Math.abs(yDistance)){				returnObject.mainAxis = "x";								if(xDistance > 0){					returnObject.polarity = 1;				} else {					returnObject.polarity = -1;				}											} else {				returnObject.mainAxis = "y";								if(yDistance > 0){					returnObject.polarity = 1;				} else {					returnObject.polarity = -1;				}			}						//speed (premultiplied with polarity in main axis)			returnObject.velocity = returnObject.polarity * Math.sqrt(square(xDistance)+square(yDistance));									return returnObject;					}																		//get X and Y from a hypotenuse (only works assuming X and Y coords are equal)		//i.e. get the vertical and horizontal values required for a fixed diagonal distance		public function getAdjacentFromHypotenuse(hypot:Number):Number{			//trace("trigAdjacent = "+Math.sqrt(sqr(hypot)/2))			return Math.sqrt(square(hypot)/2);		}																		//returns true if two objects are within the given range of each other (2D only)		//uses com.aderowbotham.utils.PositionObject		public static function getIsInRange(object1:PositionObject,object2:PositionObject,testRange:Number):Boolean{					//get x distance			var dX:Number =object1.getX() - object2.getX();						//set y distance to zero (default)			var dY:Number = 0;						//get y distance if set in position object			if(!isNaN(object1.getY()) && !isNaN(object2.getY())){				dY =object1.getY() - object2.getY();			}						//trace("getHypotenuse(dX,dY) = "+getHypotenuse(dX,dY));						//trace("testRange ="+testRange);						return (getHypotenuse(dX,dY) <= Math.abs(testRange));							}																//deprecated. use value % 360 instead		//this was written before I knew about the modulo operator!		public static function normaliseAngle(a:Number):Number{									throw new Error("normaliseAngle has been deprecated. Use: value % 360 instead.");							return a%360;			//			if(a > 359){//				a -= 360;		//			} else if (a < 0){//				a += 360;//			}			//			return a;		}																		//this tells you whether a tile in a grid (such as a square on a chessboard) is adjacent to one or more edges		//it returns an array of X and Y edge status (rows and columns)		//where -1 indicates TOP (for rows) or LEFT (for columns)		//and 1 indicates BOTTOM (for rows) or RIGHT (for columns)		//and a value of 0 indicates it is not adjacent to either edge in that axis				//!important : assumes starting row or column value of ZERO, 		//and therefore maximum row number = rows-1				//ARGUMENTS >> row to be checked, col to be checked, rows to check against, columns to check against		public function getRowAndColumnEdgeStatus(row:int,col:int,rows:int,columns:int):Array{			var rr:int = 0;			var cc:int = 0;						if(row == 0){				rr = -1;							} else if (row == rows-1){				rr = 1;			}						if(col == 0){				cc = -1;							} else if (col == columns-1){				cc = 1;			}							return new Array(rr,cc);		}														/*		* returns true of false, 		* if random % value is less than the %age argument passed		*/				public function chanceRoll(percent:uint):Boolean {					return (Math.random() < percent/100);				}									// ------ END mathematical functions ------ //	}}